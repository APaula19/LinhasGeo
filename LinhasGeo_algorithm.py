# -*- coding: utf-8 -*-

"""
/***************************************************************************
 LinhasGeoIME
                                 A QGIS plugin
 Plugin referente ao projeto de fim de curso de 2025
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2025-07-10
        copyright            : (C) 2025 by Ana Paula Pires dos Santos, Paulo Melo Coutinho Neves, Gabriella Bezerra Vale
        email                : anapaulapiressantos19@ime.eb.br
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Ana Paula Pires dos Santos, Paulo Melo Coutinho Neves, Gabriella Bezerra Vale'
__date__ = '2025-07-10'
__copyright__ = '(C) 2025 by Ana Paula Pires dos Santos, Paulo Melo Coutinho Neves, Gabriella Bezerra Vale'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

from qgis.core import (
    QgsProcessingAlgorithm,
    QgsProcessingParameterEnum,
    QgsProcessingParameterFile,
    QgsProcessingParameterFeatureSink,
    QgsFeature,
    QgsFields,
    QgsWkbTypes,
    QgsCoordinateReferenceSystem,
    QgsGeometry,
    QgsPointXY
)
from qgis.PyQt.QtCore import QCoreApplication
from geographiclib.geodesic import Geodesic
from geopy.distance import geodesic as vincenty 
from pyproj import Geod
import csv
import pandas as pd

class LinhasGeoIMEAlgorithm(QgsProcessingAlgorithm):
    """
    Algoritmo que permite o usuário importar um .xls, escolher o método e
    algoritmo geodésico, e processar os dados conforme a escolha.
    """

    def tr(self, text):
        return QCoreApplication.translate('Processing', text)

    def createInstance(self):
        return LinhasGeoIMEAlgorithm()

    def name(self):
        return 'geodesic_lines_advanced'

    def displayName(self):
        return self.tr('Linhas Geodésicas (Múltiplos Métodos)')

    def initAlgorithm(self, config=None):
        # 1. Selecionar tipo de problema
        self.addParameter(QgsProcessingParameterEnum(
            'PROBLEM_TYPE',
            self.tr('Tipo de cálculo'),
            options=[self.tr('Inverso: lat1,lon1,lat2,lon2'),
                     self.tr('Direto: lat1,lon1,azi1,dist')],
            defaultValue=0))

        # 2. Selecionar método geodésico
        self.addParameter(QgsProcessingParameterEnum(
            'METHOD',
            self.tr('Método Geodésico'),
            options=[self.tr('Karney/WGS84'),
                     self.tr('Vincenty/WGS84'),
                     self.tr('Bessel')],
            defaultValue=0))

        # 3. Arquivo CSV (compatível com ambos os formatos)
        self.addParameter(QgsProcessingParameterFile(
            'INPUT_CSV',
            self.tr('Arquivo CSV'),
            extension='csv'))

        # 4. Saída
        self.addParameter(QgsProcessingParameterFeatureSink(
            'OUTPUT',
            self.tr('Linhas geodésicas')))

    def processAlgorithm(self, parameters, context, feedback):
        problem_type = self.parameterAsEnum(parameters, 'PROBLEM_TYPE', context)
        method = self.parameterAsEnum(parameters, 'METHOD', context)
        csv_path = self.parameterAsFile(parameters, 'INPUT_CSV', context)

        # Configurar saída
        fields = QgsFields()
        sink, dest_id = self.parameterAsSink(
            parameters, 'OUTPUT', context,
            fields, QgsWkbTypes.LineString,
            QgsCoordinateReferenceSystem('EPSG:4326'))
        
                
        # Configurar o elipsoide conforme o método selecionado
        if method == 0:  # Karney/WGS84
            geod = Geodesic.WGS84
            method_name = "Karney/WGS84"

            with open(csv_path, 'r') as f:
                reader = csv.DictReader(f)
                
                for row in reader:
                    points = []
                    
                    if problem_type == 0:  # Problema Inverso
                        try:
                            if method == 2:  
                                lat1 = float(row.get('lat inicial', row.get('lat1')))
                                lon1 = float(row.get('long inicial', row.get('lon1')))
                                lat2 = float(row.get('lat final', row.get('lat2')))
                                lon2 = float(row.get('long final', row.get('lon2')))
                            else:
                                lat1 = float(row['lat1'])
                                lon1 = float(row['lon1'])
                                lat2 = float(row['lat2'])
                                lon2 = float(row['lon2'])
                            
                            # Calcular linha geodésica
                            inv = geod.Inverse(lat1, lon1, lat2, lon2)
                            line = geod.Line(lat1, lon1, inv['azi1'])
                            points.append(QgsPointXY(lon1, lat1))
                            
                            # Adiciona pontos intermediários para uma linha mais suave
                            total_dist = inv['s12']
                            steps = max(10, int(total_dist / 1000))  # Pelo menos 10 pontos ou 1 ponto por km
                            
                            for i in range(1, steps + 1):
                                dist = (i / steps) * total_dist
                                pos = line.Position(dist)
                                points.append(QgsPointXY(pos['lon2'], pos['lat2']))

                        except (KeyError, ValueError) as e:
                            feedback.reportError(f"Erro no problema inverso: {str(e)}")
                            continue

                    else:  # Problema Direto
                        try:
                            if method == 2:
                                lat1 = float(row.get('lat inicial', row.get('lat1')))
                                lon1 = float(row.get('long inicial', row.get('lon1')))
                                azi1 = float(row.get('azimute', row.get('azi1')))
                                dist_km = float(row.get('distancia (km)', row.get('dist')))
                            else:
                                lat1 = float(row['lat1'])
                                lon1 = float(row['lon1'])
                                azi1 = float(row['azi1'])
                                dist_km = float(row['dist'])
                            
                            # Gerar linha com pontos intermediários
                            points.append(QgsPointXY(lon1, lat1))
                            line = geod.Line(lat1, lon1, azi1)
                            total_dist = dist_km * 1000
                            steps = max(10, int(dist_km))  # Pelo menos 10 pontos ou 1 ponto por km
                            
                            for i in range(1, steps + 1):
                                dist = (i / steps) * total_dist
                                pos = line.Position(dist)
                                points.append(QgsPointXY(pos['lon2'], pos['lat2']))

                        except (KeyError, ValueError) as e:
                            feedback.reportError(f"Erro no problema direto: {str(e)}")
                            continue

                    # Adicionar feature (para ambos os tipos)
                    feat = QgsFeature()
                    feat.setGeometry(QgsGeometry.fromPolylineXY(points))
                    sink.addFeature(feat)
        elif method == 1:  # Vincenty/WGS84
            features = self.calcular_com_vincenty(csv_path, 
                                              'Inverso' if problem_type == 0 else 'Direto', 
                                              feedback)
            for feat in features:
                sink.addFeature(feat)
        else:  # Bessel
            features = self.calcular_com_bessel(csv_path, 
                                            'Inverso' if problem_type == 0 else 'Direto', 
                                            feedback)
            for feat in features:
                sink.addFeature(feat)


        return {'OUTPUT': dest_id}

    def calcular_com_vincenty(self, caminho_arquivo, metodo, feedback):
        """
        Função adaptada para usar com QGIS e plotar linhas geodésicas
        """
        df = pd.read_csv(caminho_arquivo)
        geod = Geodesic.WGS84
        features = []
        
        def pontos_antipodais(lat1, lon1, lat2, lon2, tol=1e-5):

            # mesma latitude com sinal trocado
            cond_lat = abs(lat1 + lat2) < tol  

            # diferença de longitude próxima de 180° (ou 0/360)
            dlon = abs((lon1 - lon2 + 180) % 360 - 180)
            cond_lon = abs(dlon - 180) < tol  

            return cond_lat and cond_lon

        if metodo == 'Inverso':
            for _, row in df.iterrows():
                try:
                    lat1, lon1, lat2, lon2 = row['lat1'], row['lon1'], row['lat2'], row['lon2']
                    
                    if pontos_antipodais(lat1, lon1, lat2, lon2):
                        feedback.reportError(
                            f"Pontos ({lat1}, {lon1}) e ({lat2}, {lon2}) são/aproximam-se de antípodas. "
                            "O método de Vincenty não converge nesse caso. Recomenda-se usar o método de Karney."
                        )
                        continue
                    
                    inv = geod.Inverse(lat1, lon1, lat2, lon2)
                    line = geod.Line(lat1, lon1, inv['azi1'])
                    
                    points1 = [QgsPointXY(lon1, lat1)]
                    points2 = [QgsPointXY(lon2, lat2)]
                    total_dist = vincenty(points1, points2, ellipsoid='WGS-84').meters
                    steps = max(10, int(total_dist / 1000))
                    
                    for i in range(1, steps + 1):
                        dist = (i / steps) * total_dist
                        pos = line.Position(dist)
                        points.append(QgsPointXY(pos['lon2'], pos['lat2']))
                    
                    feat = QgsFeature()
                    feat.setGeometry(QgsGeometry.fromPolylineXY(points))
                    features.append(feat)
                except Exception as e:
                    feedback.reportError(f"Erro Vincenty Inverso: {str(e)}")
                    continue

        elif metodo == 'Direto':
            for _, row in df.iterrows():
                try:
                    lat1, lon1, azi1, dist = row['lat1'], row['lon1'], row['azi1'], row['dist']
                    line = geod.Line(lat1, lon1, azi1)
                    total_dist = dist * 1000
                    steps = max(10, int(dist))
                    
                    points = [QgsPointXY(lon1, lat1)]
                    for i in range(1, steps + 1):
                        dist_step = (i / steps) * total_dist
                        pos = line.Position(dist_step)
                        points.append(QgsPointXY(pos['lon2'], pos['lat2']))
                    
                    feat = QgsFeature()
                    feat.setGeometry(QgsGeometry.fromPolylineXY(points))
                    features.append(feat)
                except Exception as e:
                    feedback.reportError(f"Erro Vincenty Direto: {str(e)}")
                    continue

        return features

    def calcular_com_bessel(self, caminho_arquivo, metodo, feedback):
        """
        Função adaptada para usar com QGIS e plotar linhas geodésicas
        """
        df = pd.read_csv(caminho_arquivo)
        geod = Geodesic(6377397.155, 1/299.1528128)
        features = []

        for _, row in df.iterrows():
            try:
                lat1 = row.get("lat inicial", row.get("lat1"))
                lon1 = row.get("long inicial", row.get("lon1"))
                lat2 = row.get("lat final", row.get("lat2"))
                lon2 = row.get("long final", row.get("lon2"))
                dist = row.get("distancia (km)", row.get("dist"))
                azimute = row.get("azimute", row.get("azi1"))

                if pd.notna(lat1) and pd.notna(lon1) and pd.notna(dist) and pd.notna(azimute):
                    # Problema Direto
                    line = geod.Line(lat1, lon1, azimute)
                    total_dist = float(dist) * 1000
                    steps = max(10, int(float(dist)))
                    
                    points = [QgsPointXY(lon1, lat1)]
                    for i in range(1, steps + 1):
                        dist_step = (i / steps) * total_dist
                        pos = line.Position(dist_step)
                        points.append(QgsPointXY(pos['lon2'], pos['lat2']))
                    
                    feat = QgsFeature()
                    feat.setGeometry(QgsGeometry.fromPolylineXY(points))
                    features.append(feat)
                
                elif pd.notna(lat1) and pd.notna(lon1) and pd.notna(lat2) and pd.notna(lon2):
                    # Problema Inverso
                    inv = geod.Inverse(lat1, lon1, lat2, lon2)
                    line = geod.Line(lat1, lon1, inv['azi1'])
                    total_dist = geod.inv(lon1, lat1, lon2, lat2)
                    steps = max(10, int(total_dist / 1000))
                    
                    points = [QgsPointXY(lon1, lat1)]
                    for i in range(1, steps + 1):
                        dist_step = (i / steps) * total_dist
                        pos = line.Position(dist_step)
                        points.append(QgsPointXY(pos['lon2'], pos['lat2']))
                    
                    feat = QgsFeature()
                    feat.setGeometry(QgsGeometry.fromPolylineXY(points))
                    features.append(feat)
                
            except Exception as e:
                feedback.reportError(f"Erro Bessel: {str(e)}")
                continue

        return features